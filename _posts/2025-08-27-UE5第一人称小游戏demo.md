---
title: UE5第一人称小游戏demo
date: 2025-08-27 18:00:00 +0800
categories: [项目工作]
tags: [UE5]
---

[参考文档](https://dev.epicgames.com/community/learning/tutorials/8Xn9/unreal-engine-epic-for-indies-your-first-60-minutes-with-gameplay-ability-system)

# 展示
使用C++与蓝图结合实现FPS游戏的基础功能，包括玩家角色的行走/奔跑状态及对应动画（1D 混合空间）切换、武器拾取、切换、射击、换弹和消耗品使用。基于GAS实现玩家与敌人角色的属性管理及HUD显示逻辑：包含敌人受击后的生命值动态变化、玩家技能释放时的生命与能量消耗、能量恢复及呼吸回血机制。通过动态多播委托实现能量在一段时间未消耗后自动恢复，以及拾取武器后自动更新弹药HUD。

{%
    include embed/video.html
    src='/assets/ue/uecpp_fps_demo.mp4'
    poster='/assets/ue/uecpp_fps_demo.png'
    title='uecpp fps demo'
    autoplay=false
    loop=false
    muted=false
%}

# 实现
## GAS部分
### Class ASC
首先创建一个继承自`AbilitySystemComponent`类的ASC类
```CPP
#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "AdventureAbilitySystemComponent.generated.h"

UCLASS()
class MYADVENTURE_API UAdventureAbilitySystemComponent : public UAbilitySystemComponent
{
	GENERATED_BODY()
	
};
```
### Class PlayerAttributeSet
|Health|MaxHealth|Energy|MaxEnergy|Damage|Cost|Breath|
|:---|:---|:---|:---|:---|:---|:---|
|血量|血量上限|能量|能量上限|技能伤害|能量消耗|呼吸恢复|
```CPP
DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FCharacterAttributeChangedEvent, UAttributeSet*, AttributeSet, float, OldValue, float, NewValue);

UCLASS()
class MYADVENTURE_API UAdventureCharacterAttributeSet : public UAttributeSet
{
	GENERATED_BODY()

public:
	UAdventureCharacterAttributeSet();

	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;

	virtual void PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue) override;

	virtual void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;

	// meta: 不允许 GE 直接修改 Health
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (HideFromModifiers))
	FGameplayAttributeData Health;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	FGameplayAttributeData MaxHealth;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (HideFromModifiers))
	FGameplayAttributeData Energy;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	FGameplayAttributeData MaxEnergy;

	UPROPERTY(BlueprintAssignable)
	FCharacterAttributeChangedEvent OnAttributeChanged;

	UPROPERTY(VisibleAnywhere)
	FGameplayAttributeData Damage;

	UPROPERTY(VisibleAnywhere)
	FGameplayAttributeData Cost;

	UPROPERTY(VisibleAnywhere)
	FGameplayAttributeData Breath;

	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, Health);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, MaxHealth);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, Energy);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, MaxEnergy);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, Damage);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, Cost);
	ATTRIBUTE_ACCESSORS_BASIC(UAdventureCharacterAttributeSet, Breath);
}; // Enemy AttributeSet只有Health
```
#### 玩家属性变化实现
头文件中注册4参数动态多播委托 OnAttributeChanged(BlueprintAssignable)，广播至 WBP_HUD_Basic
```CPP
void UAdventureCharacterAttributeSet::PreAttributeChange(const FGameplayAttribute & Attribute, float & NewValue)
{
	UE_LOG(LogTemp, Warning, TEXT("PreChange: Attribute '%s'"), *Attribute.AttributeName);
	if (Attribute == GetHealthAttribute()) {
		NewValue = FMath::Clamp(NewValue, 0.f, GetMaxHealth());
	} else if (Attribute == GetEnergyAttribute()) {
		NewValue = FMath::Clamp(NewValue, 0.f, GetMaxEnergy());
	}
	Super::PreAttributeChange(Attribute, NewValue);
}

void UAdventureCharacterAttributeSet::PostAttributeChange(const FGameplayAttribute & Attribute, float OldValue, float NewValue)
{
	Super::PostAttributeChange(Attribute, OldValue, NewValue);
	UE_LOG(LogTemp, Warning, TEXT("PostChange: Attribute '%s' changed %.2f -> %.2f"), *Attribute.AttributeName, OldValue, NewValue);

	if (Attribute == GetHealthAttribute()) {
		OnAttributeChanged.Broadcast(this, OldValue, NewValue);
	}
	else if (Attribute == GetMaxHealthAttribute()) {
		const float CurrentHealth = GetHealth();
		OnAttributeChanged.Broadcast(this, CurrentHealth, CurrentHealth);
	}

	if (Attribute == GetEnergyAttribute()) {
		OnAttributeChanged.Broadcast(this, OldValue, NewValue);
	}
	else if (Attribute == GetMaxEnergyAttribute()) {
		const float CurrentEnergy = GetEnergy();
		OnAttributeChanged.Broadcast(this, CurrentEnergy, CurrentEnergy);
	}
}

void UAdventureCharacterAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData & Data)
{
	if (Data.EvaluatedData.Attribute == GetDamageAttribute()) {
		const float DamageValue = GetDamage();
		const float OldHealthValue = GetHealth();
		const float MaxHealthValue = GetMaxHealth();
		const float NewHealthValue = FMath::Clamp(OldHealthValue - DamageValue, 0.f, MaxHealthValue);

		if (OldHealthValue != NewHealthValue) {
			SetHealth(NewHealthValue);
		}

		SetDamage(0.f);
	}

	if (Data.EvaluatedData.Attribute == GetCostAttribute()) {
		const float CostValue = GetCost();
		const float OldEnergyValue = GetEnergy();
		const float MaxEnergyValue = GetMaxEnergy();
		const float NewEnergyValue = FMath::Clamp(OldEnergyValue - CostValue, 0.f, MaxEnergyValue);

		if (OldEnergyValue != NewEnergyValue) {
			SetEnergy(NewEnergyValue);
		}

		SetCost(0.f);
	}

	if (Data.EvaluatedData.Attribute == GetBreathAttribute()) {
		const float breathValue = GetBreath();
		const float OldEnergyValue = GetEnergy();
		const float MaxEnergyValue = GetMaxEnergy();
		const float NewEnergyValue = FMath::Clamp(OldEnergyValue + breathValue, 0.f, MaxEnergyValue);

		if (OldEnergyValue != NewEnergyValue) {
			SetEnergy(NewEnergyValue);
		}

		SetBreath(0.f);
	}
}
```

#### UI 蓝图
<figure>
    <figcaption>WBP_HUD_Basic_EventGraph</figcaption>
    <img src="/assets/ue/WBP_HUD_Basic_EventGraph.png" alt="WBP_HUD_Basic_EventGraph">
</figure>

<figure>
    <figcaption>RefreshAttribute</figcaption>
    <img src="/assets/ue/RefreshAttribute.png" alt="RefreshAttribute">
</figure>

### Class Player
```CPP
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnToolEquipped);

UCLASS()
class MYADVENTURE_API AAdventureCharacter : public ACharacter, public IAbilitySystemInterface
{
	// ...
public:
	AAdventureCharacter();

	void OnEnergyChanged(const FOnAttributeChangeData& Data);

	void CheckBreathRegenCondition();

	void GiveItem(UItemDefinition* ItemDefinition);

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = AbilitySystemComponent)
	TObjectPtr<UAdventureAbilitySystemComponent> AdventureAbilitySystemComponent;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = AbilitySystemComponent)
	TObjectPtr<UAdventureCharacterAttributeSet> AdventureCharacterAttributeSet;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Tools)
	TObjectPtr<AEquippableToolBase> EquippedTool; // 装备的武器

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Projectile)
	int RifleProjectilesStorage = 0; // 弹药库存

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Breath")
	bool bBreathTriggered = false; // 开启呼吸恢复，确保蓝图能访问到

	UPROPERTY(BlueprintAssignable)
	FOnToolEquipped OnToolEquipped; // 拾取武器事件，触发显示弹药HUD

	FTimerHandle BreathCheckTimerHandle;

	float LastEnergyDecreaseTime = -FLT_MAX;
};

AAdventureCharacter::AAdventureCharacter()
{
	// ...

	AdventureAbilitySystemComponent = CreateDefaultSubobject<UAdventureAbilitySystemComponent>(TEXT("AdventureAbilitySystemComponent"));
	AdventureCharacterAttributeSet = CreateDefaultSubobject<UAdventureCharacterAttributeSet>(TEXT("AdventureCharacterAttributeSet"));

	// 绑定能量变化，Energy 一变化就调用 OnEnergyChanged
	AdventureAbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(AdventureCharacterAttributeSet->GetEnergyAttribute()).AddUObject(this, &AAdventureCharacter::OnEnergyChanged);
}

void AAdventureCharacter::BeginPlay()
{
	// ...

	if (AdventureAbilitySystemComponent != nullptr) {
		AdventureAbilitySystemComponent->InitAbilityActorInfo(this, this);

		GetWorld()->GetTimerManager().SetTimer(BreathCheckTimerHandle, this, &AAdventureCharacter::CheckBreathRegenCondition, 0.2f, true); // 每隔0.2s检查一次
	}
}

UAdventureAbilitySystemComponent* AAdventureCharacter::GetAbilitySystemComponent() const {
	return AdventureAbilitySystemComponent;
}
```

#### 玩家属性恢复实现
一定时间内某属性没有减少，就开始自动恢复（cod呼吸回血、塞尔达恢复能量）
```CPP
void AAdventureCharacter::OnEnergyChanged(const FOnAttributeChangeData & Data)
{
	// 记录下最后能量减少的时间戳
	if (Data.NewValue < Data.OldValue) {
		LastEnergyDecreaseTime = GetWorld()->GetTimeSeconds();
		bBreathTriggered = false;
	}
}

void AAdventureCharacter::CheckBreathRegenCondition()
{
	// 每隔0.2s检查一次，是否距离上一次能量减少过去了3s，如果是就设置flag，蓝图中继续调用恢复的 Gameplay Effect
	float Now = GetWorld()->GetTimeSeconds();
	if (!bBreathTriggered && (Now - LastEnergyDecreaseTime >= 3.f)) {
		bBreathTriggered = true;
	}
}
```
使用 SetTimerByFunctionName 达到循环执行某个函数
<figure>
    <figcaption>HUD的蓝图部分</figcaption>
    <img src="/assets/ue/HUD.png" alt="HUD的蓝图部分">
</figure>

<figure>
    <figcaption>GE 呼吸恢复能量</figcaption>
    <img src="/assets/ue/Breath.png" alt="GE 呼吸恢复能量">
</figure>

<figure>
    <figcaption>GE 奔跑消耗能量</figcaption>
    <img src="/assets/ue/CostWhenRunning.png" alt="GE 奔跑消耗能量">
</figure>

#### 拾取武器后显示弹药HUD
头文件中已声明过无参动态多播委托 OnToolEquipped(BlueprintAssignable)，拾取武器后，将事件广播到蓝图
```CPP
void AAdventureCharacter::GiveItem(UItemDefinition * ItemDefinition)
{
	switch (ItemDefinition->ItemType) {

		case EItemType::Tool: {
			UEquippableToolDefinition* ToolDefinition = Cast<UEquippableToolDefinition>(ItemDefinition);

			if (ToolDefinition != nullptr) {
				AttachTool(ToolDefinition);

				OnToolEquipped.Broadcast();
			}
			else {
				GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT("Cast to tool failed!"));
			}
			break;
		}
	}
}
```
#### HUD设计
<figure>
    <figcaption>WBP_HUD_Ammo</figcaption>
    <img src="/assets/ue/WBP_HUD_Ammo.png" alt="WBP_HUD_Ammo">
</figure>

<figure>
    <figcaption>WBP_HUD_Ammo_EventGraph</figcaption>
    <img src="/assets/ue/WBP_HUD_Ammo_EventGraph.png" alt="WBP_HUD_Ammo_EventGraph">
</figure>

<figure>
    <figcaption>WBP_HUD_Ammo_EventGraph</figcaption>
    <img src="/assets/ue/WBP_HUD_Ammo_EventGraph.png" alt="WBP_HUD_Ammo_EventGraph">
</figure>

<figure>
    <figcaption>Get_Cur_Text</figcaption>
    <img src="/assets/ue/Get_Cur_Text.png" alt="Get_Cur_Text">
</figure>

<figure>
    <figcaption>Get_Storage_Text</figcaption>
    <img src="/assets/ue/Get_Storage_Text.png" alt="Get_Storage_Text">
</figure>

## 武器部分
```CPP
class AEquippableToolBase;

UCLASS(BlueprintType, Blueprintable)
class MYADVENTURE_API ADartLauncher : public AEquippableToolBase
{
	// ...

	virtual void Init() override;

	virtual void Use() override;

	void Reload();

	UPROPERTY(EditAnywhere, Category = Projectile)
	TSubclassOf<AAdventureProjectile> ProjectileClass; // 子弹类

	UPROPERTY(BlueprintReadOnly, Category = Weapon)
	int RifleMagCapacity = 30; // 弹夹容量

	UPROPERTY(BlueprintReadOnly, Category = Projectile)
	int ProjectilesInMagazine; // 弹夹中弹药剩余量
}

void ADartLauncher::Init() {
	if (ID == "DartLauncher_Rifle") { // 武器弹夹初始弹药剩余量应为弹夹容量
		ProjectilesInMagazine = RifleMagCapacity;
	}
}

void ADartLauncher::Use()
{
	UWorld* const World = GetWorld();
	if (World != nullptr && ProjectileClass != nullptr && ProjectilesInMagazine > 0) {
		// 调整子弹的生成位置
		FVector TargetPosition = OwningCharacter->GetCameraTargetLocation();
		FVector SocketLocation = ToolMeshComponent->GetSocketLocation("Muzzle");
		FRotator SpawnRotation = UKismetMathLibrary::FindLookAtRotation(SocketLocation, TargetPosition);
		FVector SpawnLocation = SocketLocation + UKismetMathLibrary::GetForwardVector(SpawnRotation) * 10.0;
		FActorSpawnParameters ActorSpawnParams;
		ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;
		World->SpawnActor<AAdventureProjectile>(ProjectileClass, SpawnLocation, SpawnRotation, ActorSpawnParams);

		ProjectilesInMagazine--; // 射击减少弹夹剩余容量
	}
}

void ADartLauncher::Reload()
{
	GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT("Reload"));
	if (OwningCharacter) {
		if (ID == "DartLauncher_Rifle") {
			if (OwningCharacter->RifleProjectilesStorage > 0) { // 弹药库存量 > 0 进行装填
				int LoadedProjectiles = (OwningCharacter->RifleProjectilesStorage + ProjectilesInMagazine) / RifleMagCapacity ? RifleMagCapacity : (OwningCharacter->RifleProjectilesStorage + ProjectilesInMagazine);
				OwningCharacter->RifleProjectilesStorage -= LoadedProjectiles - ProjectilesInMagazine;
				ProjectilesInMagazine = LoadedProjectiles;
			}
		}
	}
}
```